"""
4
= 1+2+1
= 1+3
= 3+1

D[lcm] => 정수 N을 1, 2, 3의 합으로 나타낼 수 있는 경우의 수 (단 같은 수 연속 X)
D[i][j] => i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j (1 <= j <= 3)

- D[i][1] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1
    - 바로 전에 사용할 수 있는 수는 2, 3
    - D[i][1] = D[i-1][2] + D[i-1][3]
- D[i][2] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2
    - 바로 전에 사용할 수 있는 수는 1, 3
    - D[i][2] = D[i-2][1] + d[i-2][3]
- D[i][3] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3
    - 바로 전에 사용할 수 있는 수는 1, 2
    - D[i][3] = D[i-3][1] + d[i-3][2]

=> D[i][j] = D[i][1] + D[i][2] + D[i][3]
=> D[i][j] = D[i-1][2] + D[i-1][3] + D[i-2][1] + d[i-2][3] + D[i-3][1] + d[i-3][2]

이를 그대로 점화식의 구현에 이용한다.

if lcm = 3,
D[lcm] = [
        D[lcm-1][2] + D[lcm-1][3],  // 마지막에 사용한 수가 1인 경우의 수
        D[lcm-2][1] + D[lcm-2][3],  // 마지막에 사용한 수가 2인 경우의 수
        D[lcm-3][1] + D[lcm-3][2]  // 마지막에 사용한 수가 3인 경우의 수
]
"""
from sys import stdin

input = stdin.readline

mod: int = 1000000009
limit: int = 100000
d = [0, 0, 0] * (limit + 1)

d[0] = [1, 0, 0]
d[1] = [0, 1, 0]
d[2] = [1, 1, 1]

for i in range(3, limit + 1):
    d[i] = [
        (d[i - 1][1] + d[i - 1][2]) % mod,
        (d[i - 2][0] + d[i - 2][2]) % mod,
        (d[i - 3][0] + d[i - 3][1]) % mod
    ]

for _ in range(int(input())):
    print(sum(d[int(input()) - 1]) % mod)
